(window.webpackJsonp=window.webpackJsonp||[]).push([[371],{1125:function(v,e,_){"use strict";_.r(e);var a=_(20),t=Object(a.a)({},(function(){var v=this,e=v._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("p",[v._v("source map是为了解决开发代码与实际代码不一致时，帮助我们debug到原始开发代码的技术。\nwebpack通过配置可以自动给我们those maps文件，map文件是一种对应编译文件和源文件的方法。")]),v._v(" "),e("p",[v._v("source map的类型")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("类型")]),v._v(" "),e("th",[v._v("含义")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("source-map")]),v._v(" "),e("td",[v._v("原始代码最好的作词map质量有完整的结果,但会很慢")])]),v._v(" "),e("tr",[e("td",[v._v("eval-source-map")]),v._v(" "),e("td",[v._v("原始代码同样道理，但是最高的质量和最低的性能")])]),v._v(" "),e("tr",[e("td",[v._v("cheap-module-eval-source-map")]),v._v(" "),e("td",[v._v("原始代码(只有行内)同样道理,但是更高的质量和更低的性能")])]),v._v(" "),e("tr",[e("td",[v._v("cheap-eval-source-map")]),v._v(" "),e("td",[v._v("转换代码(行内)每个模块儿被eval执行，并且source map作为eval的一个data url")])]),v._v(" "),e("tr",[e("td",[v._v("eval")]),v._v(" "),e("td",[v._v("生成代码，每个模块儿都被eval执行并且存在@sourceUrl，带eval的构建模式能cache sourcemap")])]),v._v(" "),e("tr",[e("td",[v._v("cheap-source-map")]),v._v(" "),e("td",[v._v("转换代码(行内)，生成的sourcemap没有列表映射，从loader生成的source map没有被使用")])]),v._v(" "),e("tr",[e("td",[v._v("cheap-module-source-map")]),v._v(" "),e("td",[v._v("原始代码(只有行内)与上面一样，除了每行特点的从loader中进行映射")])])])]),v._v(" "),e("p",[v._v("看似配置相很多，其实只有五个关键字，eval、source-map、cheap、module和inline的任意组合。")]),v._v(" "),e("table",[e("thead",[e("tr",[e("th",[v._v("关键字")]),v._v(" "),e("th",[v._v("含义")])])]),v._v(" "),e("tbody",[e("tr",[e("td",[v._v("eval")]),v._v(" "),e("td",[v._v("使用eval包裹代码")])]),v._v(" "),e("tr",[e("td",[v._v("source-map")]),v._v(" "),e("td",[v._v("产生map文件")])]),v._v(" "),e("tr",[e("td",[v._v("cheap")]),v._v(" "),e("td",[v._v("不包含列信息")])]),v._v(" "),e("tr",[e("td",[v._v("module")]),v._v(" "),e("td",[v._v("包含loader的sourcemap，否则无法定义源文件")])]),v._v(" "),e("tr",[e("td",[v._v("inline")]),v._v(" "),e("td",[v._v("将map 作为data url输入，不单独生成map文件")])])])]),v._v(" "),e("ul",[e("li",[v._v("eval eval执行")]),v._v(" "),e("li",[v._v("eval-source-map 生成sourcemap文件")]),v._v(" "),e("li",[v._v("cheap-module-eval-source-map 不包含列")]),v._v(" "),e("li",[v._v("cheap-eval-source-map无法查看到真正的源代码")])]),v._v(" "),e("p",[v._v("如何选择sourcemap的类型？")]),v._v(" "),e("p",[v._v("首先，在源代码的列信息是没有意义的，只要有行信息就能完整的建立打包前后代码之间的依赖关系，因此不管是开发还是生产环境都忽略模块打包后的列信息；不管是生产环境还是开发环境，我们都需要定位debug到最原始的资源，比如定位错误到jsx、ts的原始代码而不是经过编译后的js代码；因为需要生成map文件，所以得有source map属性。")]),v._v(" "),e("p",[v._v("总结：")]),v._v(" "),e("ul",[e("li",[v._v("开发环境使用：cheap-module-eval-source-map")]),v._v(" "),e("li",[v._v("生产环境使用：cheap-module-source-map")])])])}),[],!1,null,null,null);e.default=t.exports}}]);