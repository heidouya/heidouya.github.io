(window.webpackJsonp=window.webpackJsonp||[]).push([[413],{1182:function(n,v,s){"use strict";s.r(v);var _=s(20),a=Object(_.a)({},(function(){var n=this,v=n._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[n._v("简介")]),n._v(" "),v("p",[n._v("动态规划（Dynamic Programming，DP）是运筹学的一个分支，是求解决策过程最优化的过程。20世纪50年代初，美国数学家贝尔曼（R.Bellman）等人在研究多阶段决策过程的优化问题时，提出了著名的最优化原理，从而创立了动态规划。动态规划的应用极其广泛，包括工程技术、经济、工业生产、军事以及自动化控制等领域，并在背包问题、生产经营问题、资金管理问题、资源分配问题、最短路径问题和复杂系统可靠性问题等中取得了显著的效果。\n-- 百度百科")])]),n._v(" "),v("p",[n._v("从上面的介绍可以看出，动态规划就是为了求解最优。")]),n._v(" "),v("p",[n._v("适用条件：")]),n._v(" "),v("ul",[v("li",[n._v("最优化原理（最优子结构）")])]),n._v(" "),v("p",[n._v("简单来说就是一个最优化的策略的子策略总是最优的。")]),n._v(" "),v("ul",[v("li",[n._v("无后效性")])]),n._v(" "),v("p",[n._v("简单来说就是每个状态都是过去历史的一个完整总结。")]),n._v(" "),v("ul",[v("li",[n._v("子问题的重叠性（重叠子问题）")])]),n._v(" "),v("p",[n._v("在解决最终问题的过程，多次出现了重复计算。")]),n._v(" "),v("h2",{attrs:{id:"爬楼梯"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#爬楼梯"}},[n._v("#")]),n._v(" 爬楼梯")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("题目描述：假设你正在爬楼梯。需要 n 阶你才能到达楼顶\n\n每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n注意：给定 n 是一个正整数。\n\n示例 1：\n\n输入： 2\n\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n\n1. 1 阶 + 1 阶\n2. 2 阶\n\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n\n示例 1：\n\n输入： 2\n输出： 2\n解释： 有两种方法可以爬到楼顶。\n1.  1 阶 + 1 阶\n2.  2 阶\n示例 2：\n\n输入： 3\n输出： 3\n解释： 有三种方法可以爬到楼顶。\n1.  1 阶 + 1 阶 + 1 阶\n2.  1 阶 + 2 阶\n3.  2 阶 + 1 阶\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/climbing-stairs\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n")])])]),v("p",[n._v("通过递归实现：")]),n._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code",[n._v("\n")])])]),v("p",[n._v("通过记忆优化搜索实现：")]),n._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code")])]),v("p",[n._v("通过动态规则实现：")]),n._v(" "),v("div",{staticClass:"language-js extra-class"},[v("pre",{pre:!0,attrs:{class:"language-js"}},[v("code")])]),v("h2",{attrs:{id:"最少的硬币数目"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#最少的硬币数目"}},[n._v("#")]),n._v(" 最少的硬币数目")]),n._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[n._v("题目描述：给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n示例1：\n输入: coins = [1, 2, 5], amount = 11\n\n输出: 3\n解释: 11 = 5 + 5 + 1\n\n示例2：\n输入: coins = [2], amount = 3\n\n输出: -1\n\n给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。\n\n你可以认为每种硬币的数量是无限的。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/gaM7Ch\n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。\n")])])]),v("p",[n._v("什么时候使用动态规则呢？")]),n._v(" "),v("ol",[v("li",[n._v("一个题要求给出达成某个目的的解法个数。")]),n._v(" "),v("li",[n._v("不要求给出每一种解法的对应的具体路径。")]),n._v(" "),v("li",[n._v("最值问题等可以尝试动态规则。")])]),n._v(" "),v("p",[n._v("动态规则分析路径：")]),n._v(" "),v("ol",[v("li",[n._v("递归思想明确树形思维模型：找到问题终点，思考倒退的姿势，往往可以帮助你更快速地明确状态间的关系")]),n._v(" "),v("li",[n._v("结合记忆化搜索，明确状态转移方程")]),n._v(" "),v("li",[n._v("递归代码转化为迭代表达（这一步不一定是必要的，1、2本身为思维路径，而并非代码实现。若你成长为熟手，2中分析出来的状态转移方程可以直接往循环里塞，根本不需要转换）。")])]),n._v(" "),v("p",[n._v("动态规则的概念理解起来一点都不难，难的是遇到问题后怎么建模，怎么思考，很多时候即便你知道了")]),n._v(" "),v("p",[n._v("动态规则可以理解成一种聪明的递归。")]),n._v(" "),v("p",[n._v("就好比，你知道了很多道理，但依然过不好这一生。")]),n._v(" "),v("hr"),n._v(" "),v("p",[n._v("动态规划一定是让求最值的，它的核心是穷举。")]),n._v(" "),v("p",[n._v("动态规划特点：")]),n._v(" "),v("ul",[v("li",[n._v("重叠子问题")]),n._v(" "),v("li",[n._v("状态转移方程")]),n._v(" "),v("li",[n._v("最优子结构")])]),n._v(" "),v("p",[n._v("重叠子问题和最优子结构可以看做是动态规划的一个特性，只要一个题能看到这两个，就说明可以使用动态规划，状态转移方程是解题的核心，也就是通过状态转移方程去穷举的。")]),n._v(" "),v("p",[n._v("解题套路：")]),n._v(" "),v("ul",[v("li",[n._v("明确状态（状态指的是会变的，如果dp函数的参数，或者dp数组的索引）")]),n._v(" "),v("li",[n._v("明确选择")]),n._v(" "),v("li",[n._v("明确db函数/数组的定义")]),n._v(" "),v("li",[n._v("明确 base case")])]),n._v(" "),v("p",[n._v("如何穷举？")]),n._v(" "),v("p",[n._v("写出状态转移方程，暴力穷举所有可行解。")]),n._v(" "),v("p",[n._v("如何聪明的穷举？")]),n._v(" "),v("p",[n._v("用备忘录消除重叠子问题，写出自顶向下解法。进一步，可以写出自底向上的迭代解法。再进一步可以优化空间复杂度。")])])}),[],!1,null,null,null);v.default=a.exports}}]);