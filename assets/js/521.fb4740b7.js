(window.webpackJsonp=window.webpackJsonp||[]).push([[521],{1310:function(t,e,n){"use strict";n.r(e);var o=n(20),r=Object(o.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("Mobx和Redux")]),t._v(" "),e("p",[t._v("1.共同点")]),t._v(" "),e("p",[t._v("为了解决状态管理混乱，无法有效同步的问题\n统一维护管理应用状态\n某一状态只有一个可信数据来源(通常命名为store,指状态容器)\n操作更新状态方式统一，并且可控(通常以action方式提供更新状态的途径)\n支持将store与React组件连接，如react-redux，mobx-react\n2.区别 Redux")]),t._v(" "),e("p",[t._v("Redux更多的是遵循Flux模式的一种实现，是一个JavaScript库，它所关注的主要是以下几个方面：")]),t._v(" "),e("p",[t._v("Action:一个JavaScript对象，描述动作相关信息，主要包含type属性和payload属性：\ntype:action类型\npayload:负载数据\nReducer:定义状态如何响应不同动作(action)，如何更新状态\nStore:管理action和reducer及相关的对象\n维护应用状态并支持访问状态(getState())\n支持监听action的分发，更新状态(dispatch(action))\n支持订阅store的变更(subscribe(listener))\n异步流：由于Redux所有对Store状态的变更，都应该通过action触发，异步任务(通常都是业务或获取数据任务)也不例外，而为了不将业务或数据相关的任务混入React组件中，就需要使用其他框架配合管理异步任务流程，如redux-thunk，redux-saga等\nMobx")]),t._v(" "),e("p",[t._v("Mobx是一个透明函数响应式编程的状态管理库，使得状态管理简单可伸缩：")]),t._v(" "),e("p",[t._v("Action：定义改变状态的动作函数，包括如何变更状态\nStore：集中管理模块状态(State)和动作(action)\nDerivation(衍生):从应用状态中派生而出，且没有任何其他影响的数据\n对比总结")]),t._v(" "),e("p",[t._v("1.redux将数据保存单一的store中，mobx将数据保存在分散的多个store中\n2.redux使用plain object保存数据，需要手动处理变化后的操作；mobx适用observable保存数据，数据变化后自动处理响应的操作\n3.redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数；mobx中的状态是可变的，可以直接对其进行修改\n4.mobx相对来说比较简单，在其中有很多的抽象，mobx更多的使用面向对象的编程思维；redux会比较复杂，因为其中的函数式编程思想掌握起来不是那么容易，同时需要借助一系列的中间件来处理异步和副作用\n5.mobx中有更多的抽象和封装，调试比较困难，同时结果也难以预测；而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易")])])}),[],!1,null,null,null);e.default=r.exports}}]);