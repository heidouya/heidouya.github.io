(window.webpackJsonp=window.webpackJsonp||[]).push([[529],{1318:function(t,e,o){"use strict";o.r(e);var n=o(20),p=Object(n.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("在React中，数据传递一般使用props传递数据，维持单向数据流，这样可以让组件之间的关系变得简单且可预测，但是单向数据流在某些场景中并不适用。单纯一对父子组件传递并无问题，但是组件之间层层依赖深入，props就需要层层传递，很显然这样做太繁琐了")]),t._v(" "),e("p",[t._v("Context提供了一种在组件之间共享此类值的方式，而不必显式的通过组件书的层层传递props")]),t._v(" "),e("p",[t._v("可以把context当作特定一个组件树内共享的store，用来当作数据传递。简单来说，当你不想在组件树种通过层层传递props或者satte的方式来传递数据时，可以使用context来实现跨层级的组件数据传递")]),t._v(" "),e("p",[t._v("JS的代码块在执行期间，会创建一个相应的作用域链，这个作用域链记录着运行时JS代码块执行期间所能访问的活动对象，包括变量和函数，JS程序通过作用域链访问到代码块内部或者外部的变量和函数")]),t._v(" "),e("p",[t._v("假如以JS的作用域链作为类比，React组件提供的context对象其实好比一个提供给子组件访问的作用域，而context对象的属性可以看成作用域上的活动对象。由于组件的context由其父节点链上所有组件通过getChildContext()返回的context对象组合而成，所以，组件通过context是可以访问到其父组件链上所有节点组件提供的context属性。")])])}),[],!1,null,null,null);e.default=p.exports}}]);